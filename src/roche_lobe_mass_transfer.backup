/**
 * @file    roche_lobe_mass_transfer.c
 * @brief   Binary‑star sink operator: Roche‑lobe overflow (RLOF),
 *          non‑conservative mass loss, common‑envelope drag,
 *          and gravitational‑wave decay – **momentum‑ & angular‑momentum
 *          conserving version**.
 *
 * Implements
 *   1. Ritter‑type RLOF (Ritter 1988; Kolb & Ritter 1990) with optional
 *      donor mass–radius evolution.
 *   2. Optional systemic mass loss (parameter *rlmt_loss_fraction*).
 *   3. Chandrasekhar / Ostriker dynamical friction inside a common envelope
 *      (Ostriker 1999 – optional) with a safety cap on the kick magnitude.
 *   4. Peters (1964) gravitational‑wave back‑reaction (optional).
 *
 * New in this version
 *   • **Exact conservation of total *angular* momentum** during RLOF if the
 *     stream is assumed to carry the donor’s specific orbital AM.
 *   • **Safety cap** on CE‑drag kicks (parameter *ce_max_kick_fraction*).
 *   • **Donor radius** can follow a power‑law R(M) relation
 *     (parameters *rlmt_R_slope*, *rlmt_R_ref_mass*, *rlmt_R_ref_radius*).
 *
 * The file can simply replace
 *   `roche_lobe_mass_transfer.c` in REBOUNDx ≥ v3.3.
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "rebound.h"
#include "reboundx.h"

/* ---------- tiny helpers --------------------------------------------------- */
static inline void cross3(const double ax, const double ay, const double az,
                          const double bx, const double by, const double bz,
                          double* const rx, double* const ry, double* const rz){
    *rx = ay*bz - az*by;
    *ry = az*bx - ax*bz;
    *rz = ax*by - ay*bx;
}

static inline double dot3(const double ax, const double ay, const double az,
                          const double bx, const double by, const double bz){
    return ax*bx + ay*by + az*bz;
}

/* ---------- helper for Ostriker drag prefactor ----------------------------- */
static double mach_piece_sub(const double mach){
    /* Integral I(M) for sub‑sonic Mach numbers (Ostriker 1999, Eq. 13).   */
    /* Series truncated at O(M⁵).                                          */
    if (mach < 0.02){
        const double m2 = mach*mach;
        return  m2*mach/3.        /* ⅓ M³  */
              + m2*m2*mach/5.;    /* ⅕ M⁵  */
    }
    return 0.5*log((1.+mach)/(1.-mach)) - mach;   /* analytic form for M<1   */
}

static double calculate_pre_factor(const double mach, const double xmin){
    /* Coulomb‑logarithm–like term (I) valid for all Mach numbers.         */
    const double coul = log(1./xmin);
    if (mach > 1.0){                /* supersonic: classical Chandrasekhar   */
        return coul;
    }
    return fmin(coul, mach_piece_sub(mach));  /* sub‑sonic: Ostriker (1999)  */
}

/* ========================================================================== */
void rebx_roche_lobe_mass_transfer(struct reb_simulation* const sim,
                                   struct rebx_operator*     const operator,
                                   const double                     dt)
{
    struct rebx_extras* const rebx = sim->extras;

    /* --------  indices of donor / accretor  ------------------------------- */
    int* donor_idx_ptr     = rebx_get_param(rebx, operator->ap, "rlmt_donor");
    int* accretor_idx_ptr  = rebx_get_param(rebx, operator->ap, "rlmt_accretor");

    if (!donor_idx_ptr || !accretor_idx_ptr){
        rebx_error(rebx, "Need to set rlmt_donor and rlmt_accretor.\n");
        return;
    }
    const int donor_idx    = *donor_idx_ptr;
    const int accretor_idx = *accretor_idx_ptr;

    if (donor_idx >= sim->N || accretor_idx >= sim->N ||
        donor_idx < 0      || accretor_idx < 0){
        rebx_error(rebx, "rlmt_donor or rlmt_accretor index out of range.\n");
        return;
    }

    struct reb_particle* donor     = &sim->particles[donor_idx];
    struct reb_particle* accretor  = &sim->particles[accretor_idx];

    /* --------  effect‑specific parameters  -------------------------------- */
    const double* Hp_ptr         = rebx_get_param(rebx, donor->ap,     "rlmt_Hp");
    const double* mdot0_ptr      = rebx_get_param(rebx, donor->ap,     "rlmt_mdot0");
    const double* loss_frac_ptr  = rebx_get_param(rebx, operator->ap,  "rlmt_loss_fraction");

    /* Donor mass‑radius evolution (optional) */
    const double* R_slope_ptr    = rebx_get_param(rebx, donor->ap,     "rlmt_R_slope");
    const double* R_refM_ptr     = rebx_get_param(rebx, donor->ap,     "rlmt_R_ref_mass");
    const double* R_refR_ptr     = rebx_get_param(rebx, donor->ap,     "rlmt_R_ref_radius");

    /* Common‑envelope parameters (optional) */
    const double* ce_rho0_ptr    = rebx_get_param(rebx, operator->ap,  "ce_rho0");
    const double* ce_alpha_rho_ptr = rebx_get_param(rebx, operator->ap,"ce_alpha_rho");
    const double* ce_cs_ptr      = rebx_get_param(rebx, operator->ap,  "ce_cs");
    const double* ce_alpha_cs_ptr= rebx_get_param(rebx, operator->ap,  "ce_alpha_cs");
    const double* ce_xmin_ptr    = rebx_get_param(rebx, operator->ap,  "ce_xmin");
    const double* ce_Qd_ptr      = rebx_get_param(rebx, operator->ap,  "ce_Qd");
    const double* ce_kick_frac_ptr = rebx_get_param(rebx, operator->ap,"ce_max_kick_fraction");

    /* Gravitational‑wave parameters (optional) */
    const double* gw_c_ptr       = rebx_get_param(rebx, operator->ap,  "gw_c");
    const int*    gw_on_ptr      = rebx_get_param(rebx, operator->ap,  "gw_decay_on");

    if (!Hp_ptr || !mdot0_ptr){
        rebx_error(rebx, "Need to set rlmt_Hp and rlmt_mdot0 on donor particle.\n");
        return;
    }

    /* --------------------- physical constants & shortcuts ----------------- */
    const double Hp      = *Hp_ptr;
    const double mdot0   = *mdot0_ptr;

    /* Clamp loss fraction to [0,1] */
    double loss_frac = (loss_frac_ptr ? *loss_frac_ptr : 0.);
    if (loss_frac < 0.)      loss_frac = 0.;
    else if (loss_frac > 1.) loss_frac = 1.;

    /* Donor R(M) parameters */
    const double R_slope =  (R_slope_ptr  ? *R_slope_ptr  : 0.0);
    const double R_refM  =  (R_refM_ptr   ? *R_refM_ptr   : 1.0); /* avoid ÷0 */
    const double R_refR  =  (R_refR_ptr   ? *R_refR_ptr   : donor->r);

    /* Common‑envelope parameters */
    const double ce_rho0      = ce_rho0_ptr      ? *ce_rho0_ptr     : 0.;
    const double ce_alpha_rho = ce_alpha_rho_ptr ? *ce_alpha_rho_ptr: 0.;
    const double ce_cs        = ce_cs_ptr        ? *ce_cs_ptr       : 0.;
    const double ce_alpha_cs  = ce_alpha_cs_ptr  ? *ce_alpha_cs_ptr : 0.;
    const double ce_xmin      = ce_xmin_ptr      ? *ce_xmin_ptr     : 0.;
    const double ce_Qd        = ce_Qd_ptr        ? *ce_Qd_ptr       : 0.;
    const double ce_kick_frac = ce_kick_frac_ptr ? *ce_kick_frac_ptr: 0.3; /* default */

    /* ----------------------------------------------------------------------
     *  STEP 1 :  Roche‑lobe overflow mass transfer
     * ------------------------------------------------------------------- */

    /* 1.1 separation of the components */
    const double dx = donor->x - accretor->x;
    const double dy = donor->y - accretor->y;
    const double dz = donor->z - accretor->z;
    const double r  = sqrt(dx*dx + dy*dy + dz*dz);

    /* 1.2 Roche‑lobe radius (Eggleton 1983) */
    const double q        = donor->m / accretor->m;
    const double q13      = cbrt(q);
    const double rl       = r * (0.49*q13*q13) / (0.6*q13*q13 + log(1.+q13));

    /* 1.3 Ritter (1988) mass‑loss rate */
    const double Rd_old   = donor->r;         /* donor radius before this step */
    const double mdot     = -mdot0 * exp((Rd_old - rl)/Hp);      /* <0 for loss */
    double       dM       = mdot * dt;        /* negative value */

    /* Prevent donor from becoming negative mass in one shot */
    if (donor->m + dM <= 0.){
        dM = -donor->m;
    }
    const double mass_loss      = -dM;                     /* positive scalar */
    const double mass_accreted  = mass_loss * (1. - loss_frac);
    const double mass_ejected   = mass_loss * loss_frac;

    /* 1.4 Linear‑momentum bookkeeping ------------------------------------ */
    /* velocities *before* any mass change */
    const double vdx0 = donor->vx;
    const double vdy0 = donor->vy;
    const double vdz0 = donor->vz;
    const double vax0 = accretor->vx;
    const double vay0 = accretor->vy;
    const double vaz0 = accretor->vz;

    const double Md0   = donor->m;
    const double Ma0   = accretor->m;

    /* ---- update masses ---- */
    donor->m    -= mass_loss;
    accretor->m += mass_accreted;
    const double Md1 = donor->m;
    const double Ma1 = accretor->m;

    /* ---- first: conserve *linear* momentum exactly ---- */
    const double px_a = Ma0 * vax0 + mass_accreted * vdx0;
    const double py_a = Ma0 * vay0 + mass_accreted * vdy0;
    const double pz_a = Ma0 * vaz0 + mass_accreted * vdz0;

    accretor->vx = px_a / Ma1;
    accretor->vy = py_a / Ma1;
    accretor->vz = pz_a / Ma1;
    /* donor velocity unchanged (mass subtracted at same v) */

    /* 1.5 --- angular‑momentum correction  --------------------------------
     *
     * The stream carries the donor’s specific orbital AM j_stream = r_d×v_d
     * but we injected its linear momentum at the accretor’s position,
     * r_a.  The difference ΔL = m_acc (r_d−r_a)×v_d must be restored.
     *
     * We add a small tangential kick Δv_L to the accretor (and the opposite
     * to the donor) such that
     *          r_a × (Ma1 Δv_L) =  ΔL           (to first order)
     * This preserves *linear* momentum when both bodies receive opposite
     * kicks and exactly restores the missing orbital AM when
     * ΔL·r_a ≈ 0  (which is true for circular orbits and still excellent
     * in mildly eccentric systems).                                      */
    /* --- barycentre (with updated masses!) --- */
    const double Mtot1 = Md1 + Ma1;
    const double Rcmx1 = (Md1*donor->x  + Ma1*accretor->x) / Mtot1;
    const double Rcmy1 = (Md1*donor->y  + Ma1*accretor->y) / Mtot1;
    const double Rcmz1 = (Md1*donor->z  + Ma1*accretor->z) / Mtot1;

    /* r‑vectors from CM (after mass change but before kick) */
    const double rx_d = donor->x   - Rcmx1;
    const double ry_d = donor->y   - Rcmy1;
    const double rz_d = donor->z   - Rcmz1;

    const double rx_a = accretor->x - Rcmx1;
    const double ry_a = accretor->y - Rcmy1;
    const double rz_a = accretor->z - Rcmz1;

    /* ΔL that still needs to be added to system (vector form) */
    double Lcorr_x, Lcorr_y, Lcorr_z;
    cross3((rx_d), (ry_d), (rz_d),
           vdx0, vdy0, vdz0,
           &Lcorr_x, &Lcorr_y, &Lcorr_z);
    const double fac_mass = mass_accreted;
    Lcorr_x *= fac_mass;
    Lcorr_y *= fac_mass;
    Lcorr_z *= fac_mass;

    /* Subtract the angular momentum that *was* already injected
     * at r_a × (m_acc v_d)                                          */
    double Linj_x, Linj_y, Linj_z;
    cross3((rx_a), (ry_a), (rz_a),
           vdx0, vdy0, vdz0,
           &Linj_x, &Linj_y, &Linj_z);
    Linj_x *= fac_mass;
    Linj_y *= fac_mass;
    Linj_z *= fac_mass;

    const double dLx = Lcorr_x - Linj_x;
    const double dLy = Lcorr_y - Linj_y;
    const double dLz = Lcorr_z - Linj_z;

    /* If |ΔL| is non‑negligible, compute Δv_L for accretor */
    const double r_a_sq = rx_a*rx_a + ry_a*ry_a + rz_a*rz_a;
    const double dL_mag_sq = dLx*dLx + dLy*dLy + dLz*dLz;

    if (dL_mag_sq > 0.){
        /* Δv_L = (ΔL × r_a)/(Ma1 |r_a|²)   (purely tangential component) */
        double tmpx, tmpy, tmpz;
        cross3(dLx, dLy, dLz,
               rx_a, ry_a, rz_a,
               &tmpx, &tmpy, &tmpz);

        const double inv = 1.0 / (Ma1 * r_a_sq + 1e-99);
        const double dvx_L = tmpx * inv;
        const double dvy_L = tmpy * inv;
        const double dvz_L = tmpz * inv;

        /* Apply opposite kicks to conserve *linear* momentum */
        accretor->vx += dvx_L;
        accretor->vy += dvy_L;
        accretor->vz += dvz_L;

        donor->vx   -= dvx_L * (Ma1 / Md1);
        donor->vy   -= dvy_L * (Ma1 / Md1);
        donor->vz   -= dvz_L * (Ma1 / Md1);
    }

    /* 1.6 --- donor radius update, if desired ----------------------------- */
    if (R_slope != 0.){
        const double rd_new = R_refR * pow(donor->m / R_refM, R_slope);
        if (rd_new > 0.){
            donor->r = rd_new;
        }
    }
    const double Rd = donor->r;   /* (possibly updated) */

    /* ----------------------------------------------------------------------
     *  STEP 2 :  Common‑envelope dynamical friction (optional)
     * ------------------------------------------------------------------- */
    if (ce_rho0 > 0. && ce_cs > 0. && r < Rd){
        /* local envelope stratification */
        const double r_ratio = r / Rd;
        const double rho     = ce_rho0 * pow(r_ratio, ce_alpha_rho);
        const double cs      = ce_cs   * pow(r_ratio, ce_alpha_cs);

        /* relative velocity (updated by mass transfer & AM correction) */
        const double vrelx   = accretor->vx - donor->vx;
        const double vrely   = accretor->vy - donor->vy;
        const double vrelz   = accretor->vz - donor->vz;
        const double vrel    = sqrt(vrelx*vrelx + vrely*vrely + vrelz*vrelz);

        if (vrel > 0. && rho > 0.){
            const double mach = vrel / cs;
            const double I    = calculate_pre_factor(mach, (ce_xmin>0.?ce_xmin:1e-4));

            /* gravitational drag term (Ostriker 1999; vector form) */
            const double m_a   = accretor->m;
            double fc  = 4.*M_PI*sim->G*sim->G * m_a * rho / (vrel*vrel*vrel) * I;

            /* direct hydrodynamic (accretion) term, optional */
            if (ce_Qd > 0. && accretor->r > 0.){
                fc += M_PI * rho * accretor->r * accretor->r * vrel * ce_Qd / m_a;
            }

            /* Δv for accretor */
            double dvx = -fc * vrelx * dt;
            double dvy = -fc * vrely * dt;
            double dvz = -fc * vrelz * dt;

            /* --- safety cap: |Δv| ≤ f_max v_rel ------------------------- */
            const double dv_mag = sqrt(dvx*dvx + dvy*dvy + dvz*dvz);
            const double vcap   = ce_kick_frac * vrel;
            if (dv_mag > vcap){
                const double scale = vcap / dv_mag;
                dvx *= scale;  dvy *= scale;  dvz *= scale;
            }

            /* apply to accretor */
            accretor->vx += dvx;
            accretor->vy += dvy;
            accretor->vz += dvz;

            /* back‑reaction on donor’s core */
            if (donor->m > 0.){
                donor->vx -= dvx * (m_a / donor->m);
                donor->vy -= dvy * (m_a / donor->m);
                donor->vz -= dvz * (m_a / donor->m);
            }
        }
    }

    /* ----------------------------------------------------------------------
     *  STEP 3 :  Gravitational‑wave back‑reaction (optional)
     * ------------------------------------------------------------------- */
    if (gw_c_ptr && (*gw_c_ptr > 0.) && gw_on_ptr && (*gw_on_ptr != 0)){
        /* Current orbit *after* mass‑transfer & CE‑drag */
        struct reb_orbit o = reb_orbit_from_particle(sim->G, *donor, *accretor);

        if (o.a > 0.){
            const double m1 = donor->m;
            const double m2 = accretor->m;
            const double c  = *gw_c_ptr;
            const double e  = o.e;
            const double a  = o.a;
            const double G3 = sim->G * sim->G * sim->G;

            /* Peters’ secular rates */
            const double fac_a = -64./5. * G3*m1*m2*(m1+m2) /
                                 (pow(c,5)*pow(a,3)*pow(1.-e*e,3.5)) *
                                 (1.+73./24.*e*e + 37./96.*e*e*e*e);

            const double fac_e = -304./15. * e * G3*m1*m2*(m1+m2) /
                                 (pow(c,5)*pow(a,4)*pow(1.-e*e,2.5)) *
                                 (1.+121./304.*e*e);

            double a_new = a + fac_a * dt;
            double e_new = e + fac_e * dt;

            if (a_new < 0.)       a_new = 0.;
            if (e_new < 0.)       e_new = 0.;
            if (e_new > 0.999999) e_new = 0.999999;

            /* -------- keep system barycentre fixed -------------------- */
            const double Mtot = m1 + m2;
            const double Rcmx = (m1*donor->x  + m2*accretor->x) / Mtot;
            const double Rcmy = (m1*donor->y  + m2*accretor->y) / Mtot;
            const double Rcmz = (m1*donor->z  + m2*accretor->z) / Mtot;
            const double Vcmx = (m1*donor->vx + m2*accretor->vx) / Mtot;
            const double Vcmy = (m1*donor->vy + m2*accretor->vy) / Mtot;
            const double Vcmz = (m1*donor->vz + m2*accretor->vz) / Mtot;

            /* Generate NEW relative orbit (donor around accretor) */
            struct reb_particle np =
                reb_particle_from_orbit(sim->G, *accretor, m1,
                                        a_new, e_new,
                                        o.inc, o.Omega, o.omega, o.f);

            /* relative vectors (new) */
            const double rx_rel = np.x - accretor->x;
            const double ry_rel = np.y - accretor->y;
            const double rz_rel = np.z - accretor->z;

            const double vx_rel = np.vx - accretor->vx;
            const double vy_rel = np.vy - accretor->vy;
            const double vz_rel = np.vz - accretor->vz;

            /* place the two bodies around the *same* barycentre */
            const double frac_d =   m2 / Mtot;   /* donor offset factor      */
            const double frac_a =  -m1 / Mtot;   /* accretor offset factor   */

            donor->x  = Rcmx + frac_d * rx_rel;
            donor->y  = Rcmy + frac_d * ry_rel;
            donor->z  = Rcmz + frac_d * rz_rel;

            accretor->x = Rcmx + frac_a * rx_rel;
            accretor->y = Rcmy + frac_a * ry_rel;
            accretor->z = Rcmz + frac_a * rz_rel;

            donor->vx = Vcmx + frac_d * vx_rel;
            donor->vy = Vcmy + frac_d * vy_rel;
            donor->vz = Vcmz + frac_d * vz_rel;

            accretor->vx = Vcmx + frac_a * vx_rel;
            accretor->vy = Vcmy + frac_a * vy_rel;
            accretor->vz = Vcmz + frac_a * vz_rel;
        }
    }

    /* ------------------------------------------------------------------- */
    /* Remove donor if fully evaporated, detach operator                   */
    if (donor->m <= 0.){
        reb_simulation_remove_particle(sim, donor_idx, 1);
        rebx_remove_operator(rebx, operator);      /* stops further calls */
        reb_simulation_move_to_com(sim);
        return;
    }

    /* Re‑centre the simulation (cheap, keeps integrator happy)            */
    reb_simulation_move_to_com(sim);
}
